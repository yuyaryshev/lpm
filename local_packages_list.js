const localPackagesList = {
    "policies": {
        "ytypescript_lib_policy": [],
        "ytypescript_client_server_policy": []
    },
    "classification": {
        "useLocalByDefault": true,
        "enforceVersionByDefault": false,
        "ignoreVersion": [],
        "enforceVersion": [],
        "local": [],
        "nonLocal": [
            "react-ace"
        ],
        "default": [
            "@mojotech/json-type-validation",
            "@projectstorm/react-diagrams",
            "alation-alfa-bank-dg",
            "alchemy_node",
            "alchemy_web_client",
            "alfadg",
            "babel-plugin-runtime-logger",
            "babel-typescript-sample",
            "backup_lib",
            "basic_node",
            "better-sqlite3",
            "deployer_server",
            "empty_project",
            "express_hello_world",
            "fslib",
            "google_drive_yya_02",
            "googleapis",
            "hello_lit_html",
            "homebudget2020",
            "InformaticaMappingParser",
            "invest_heroes",
            "invest_heroes_ui",
            "issue_loader",
            "istanbuljs",
            "jmarceli-react-ts-library",
            "mentality",
            "MetaIDE",
            "my_wins",
            "neuro",
            "parse_factorio_api_docs",
            "path_proxy",
            "penitrator",
            "polymer_hello_world",
            "portal",
            "rbtree",
            "react-hot-boilerplate",
            "rxjs_test",
            "selenium",
            "server_store",
            "site_notify_server",
            "skill_tree_vis",
            "ssh_js",
            "ssh_js_lite",
            "testItog",
            "token_test",
            "typescript1",
            "utkonos_watch",
            "warriorjs",
            "yatasks_one_api",
            "ycmd",
            "ycplmon",
            "ydiskmon",
            "yinstrumenter",
            "ymultirepo",
            "yproject_policy",
            "ystd",
            "ystd_server",
            "ystd_test_consumer",
            "ysurvey",
            "yya_test"
        ]
    },
    "packages": {
        "alchemy_web_client": {
            "name": "alchemy_web_client",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\invest_heroes_ui",
            "enforceVersion": false
        },
        "alchemy_node": {
            "name": "alchemy_node",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\alchemy_node",
            "enforceVersion": false
        },
        "babel-plugin-runtime-logger": {
            "name": "babel-plugin-runtime-logger",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\babel-plugin-runtime-logger",
            "enforceVersion": false
        },
        "backup_lib": {
            "name": "backup_lib",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\backup_lib",
            "enforceVersion": false
        },
        "basic_node": {
            "name": "basic_node",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\basic_node",
            "enforceVersion": false
        },
        "testItog": {
            "name": "testItog",
            "version": "0.0.2",
            "path": "D:\\b\\Mine\\GIT_Work\\site_test",
            "enforceVersion": false
        },
        "site_notify_server": {
            "name": "site_notify_server",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\split_sql_to_files",
            "enforceVersion": false
        },
        "invest_heroes": {
            "name": "invest_heroes",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\invest_heroes",
            "enforceVersion": false
        },
        "issue_loader": {
            "name": "issue_loader",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\issue_loader_old_before_2020_03_06",
            "enforceVersion": false
        },
        "fslib": {
            "name": "fslib",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\fslib",
            "enforceVersion": false
        },
        "deployer_server": {
            "name": "deployer_server",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\deployer",
            "enforceVersion": false
        },
        "empty_project": {
            "name": "empty_project",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\ycomponents",
            "enforceVersion": false
        },
        "express_hello_world": {
            "name": "express_hello_world",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\express_hello_world",
            "enforceVersion": false
        },
        "server_store": {
            "name": "server_store",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\ut_generator",
            "enforceVersion": false
        },
        "googleapis": {
            "name": "googleapis",
            "version": "34.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\google-api-nodejs-client",
            "enforceVersion": false
        },
        "google_drive_yya_02": {
            "name": "google_drive_yya_02",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\google_drive_yya_02",
            "enforceVersion": false
        },
        "InformaticaMappingParser": {
            "name": "InformaticaMappingParser",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\InformaticaMappingParser",
            "enforceVersion": false
        },
        "invest_heroes_ui": {
            "name": "invest_heroes_ui",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\invest_heroes_ui_bak",
            "enforceVersion": false
        },
        "istanbuljs": {
            "name": "istanbuljs",
            "version": "2.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\istanbuljs",
            "enforceVersion": false
        },
        "hello_lit_html": {
            "name": "hello_lit_html",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\react_hello_world",
            "enforceVersion": false
        },
        "mentality": {
            "name": "mentality",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\mentality",
            "enforceVersion": false
        },
        "MetaIDE": {
            "name": "MetaIDE",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\MetaIDE",
            "enforceVersion": false
        },
        "portal": {
            "name": "portal",
            "version": "0.0.1",
            "path": "D:\\b\\Mine\\GIT_Work\\yya_test_dir",
            "enforceVersion": false
        },
        "my_wins": {
            "name": "my_wins",
            "version": "1.0.14",
            "path": "D:\\b\\Mine\\GIT_Work\\my_wins",
            "enforceVersion": false
        },
        "neuro": {
            "name": "neuro",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\neuro",
            "enforceVersion": false
        },
        "yya_test": {
            "name": "yya_test",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\notify_server — копия",
            "enforceVersion": false
        },
        "parse_factorio_api_docs": {
            "name": "parse_factorio_api_docs",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\parse_factorio_api_docs",
            "enforceVersion": false
        },
        "path_proxy": {
            "name": "path_proxy",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\path_proxy",
            "enforceVersion": false
        },
        "penitrator": {
            "name": "penitrator",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\penitrator",
            "enforceVersion": false
        },
        "polymer_hello_world": {
            "name": "polymer_hello_world",
            "path": "D:\\b\\Mine\\GIT_Work\\polymer_hello_world",
            "enforceVersion": false
        },
        "rbtree": {
            "name": "rbtree",
            "version": "0.1.0",
            "path": "D:\\b\\Mine\\GIT_Work\\rb-tree",
            "enforceVersion": false
        },
        "@projectstorm/react-diagrams": {
            "name": "@projectstorm/react-diagrams",
            "path": "D:\\b\\Mine\\GIT_Work\\react-diagrams",
            "enforceVersion": false
        },
        "react-hot-boilerplate": {
            "name": "react-hot-boilerplate",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\react-hot-boilerplate",
            "enforceVersion": false
        },
        "rxjs_test": {
            "name": "rxjs_test",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\rxjs_test",
            "enforceVersion": false
        },
        "selenium": {
            "name": "selenium",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\selenium",
            "enforceVersion": false
        },
        "skill_tree_vis": {
            "name": "skill_tree_vis",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\skill_tree_vis",
            "enforceVersion": false
        },
        "ssh_js": {
            "name": "ssh_js",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\ssh_js",
            "enforceVersion": false
        },
        "ssh_js_lite": {
            "name": "ssh_js_lite",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\tar_backup",
            "enforceVersion": false
        },
        "babel-typescript-sample": {
            "name": "babel-typescript-sample",
            "version": "0.7.0",
            "path": "D:\\b\\Mine\\GIT_Work\\TypeScript-Babel-Starter",
            "enforceVersion": false
        },
        "typescript1": {
            "name": "typescript1",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\typescript1",
            "enforceVersion": false
        },
        "utkonos_watch": {
            "name": "utkonos_watch",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\utkonos_watch_release",
            "enforceVersion": false
        },
        "ycmd": {
            "name": "ycmd",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\ycmd",
            "enforceVersion": false
        },
        "ycplmon": {
            "name": "ycplmon",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\Ycplmon_amaglion",
            "enforceVersion": false
        },
        "ydiskmon": {
            "name": "ydiskmon",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\ydiskmon",
            "enforceVersion": false
        },
        "yinstrumenter": {
            "name": "yinstrumenter",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\yinstrumenter",
            "enforceVersion": false
        },
        "ymultirepo": {
            "name": "ymultirepo",
            "version": "0.0.8",
            "path": "D:\\b\\Mine\\GIT_Work\\ymultirepo",
            "enforceVersion": false
        },
        "ystd": {
            "name": "ystd",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\ystd",
            "enforceVersion": false
        },
        "homebudget2020": {
            "name": "homebudget2020",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\HomeBudget2020",
            "enforceVersion": false
        },
        "react-ace": {
            "name": "react-ace",
            "version": "9.1.2",
            "path": "D:\\b\\Mine\\GIT_Work\\react-ace",
            "enforceVersion": false
        },
        "ysurvey": {
            "name": "ysurvey",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\ysurvey",
            "enforceVersion": false
        },
        "ystd_test_consumer": {
            "name": "ystd_test_consumer",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\ystd_test_consumer",
            "enforceVersion": false
        },
        "yproject_policy": {
            "name": "yproject_policy",
            "version": "0.0.1",
            "path": "D:\\b\\Mine\\GIT_Work\\yproject_policy2",
            "enforceVersion": false
        },
        "alfadg": {
            "name": "alfadg",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\alfadg",
            "enforceVersion": false
        },
        "token_test": {
            "name": "token_test",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\token_test",
            "enforceVersion": false
        },
        "warriorjs": {
            "name": "warriorjs",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\warriorjs",
            "enforceVersion": false
        },
        "ystd_server": {
            "name": "ystd_server",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\ystd_server",
            "enforceVersion": false
        },
        "yatasks_one_api": {
            "name": "yatasks_one_api",
            "version": "1.0.0",
            "path": "D:\\b\\Mine\\GIT_Work\\yatasks_one_api",
            "enforceVersion": false
        }
    }
};
// --- SETTINGS ABOVE ---
const splitter = `//${""} --- SETTINGS ABOVE ---`;
const { join, resolve, dirname, basename } = require('path');
const { readdirSync, writeFileSync, existsSync, readFileSync, rmdirSync, mkdirSync, linkFileSync } = require('fs');
const { execSync } = require('child_process');

const TEMP_DIR = resolve("TEMP_YMULTIREPO");

function recreateTempDir() {
    try {
        rmdirSync(TEMP_DIR, { recursive: true });
    } catch(e) {
        if (e.code !== "ENOENT")
            throw e;
    }
    mkdirSync(TEMP_DIR);
}
recreateTempDir();

const LOCAL_PACKAGES_LIST_PATH = __filename;
const LOCAL_PACKAGES_PATH = "..";
const LOCAL_PACKAGES_PATH_RESOLVED = dirname(LOCAL_PACKAGES_LIST_PATH);

// console.log(`LOCAL_PACKAGES_LIST_PATH = ${LOCAL_PACKAGES_LIST_PATH}`);
// console.log(`LOCAL_PACKAGES_PATH_RESOLVED = ${LOCAL_PACKAGES_PATH_RESOLVED}`);

const localPackageNames = [
    ...new Set([
        ...localPackagesList.classification.local,
        ...(localPackagesList.classification.useLocalByDefault ? localPackagesList.classification.default : []),
    ]),
];
const effectiveLocalPackages = {};
for (let packageName of localPackageNames) {
    const packageItem = localPackagesList.packages[packageName];
    if (!packageItem) continue;
	packageItem.enforceVersion = localPackagesList.classification.ignoreVersion.includes(packageName) ? false :
		(localPackagesList.classification.enforceVersion.includes(packageName) ? true :
		localPackagesList.classification.enforceVersionByDefault || false);
    effectiveLocalPackages[packageName] = packageItem;
}


function ymultirepoRemap(p, context) {
	if(!context.ymultirepoRemap)
		context.ymultirepoRemap = {};
	context.ymultirepoRemap.packageIndex = (context.ymultirepoRemap.packageIndex || -1) + 1;
	
    if (effectiveLocalPackages && p.dependencies)
        for (let k in p.dependencies) {
            const localPackage = effectiveLocalPackages[k];
            if (localPackage) {
				if(localPackage.enforceVersion) {
					// TODO Check local package version against dependencies[k]
					// Use this package https://www.npmjs.com/package/semver
					// The only problem is that local_packages.js have no "node_modules" folder at all!
					// Should I use a subfolder (ymultirepo?) to host "node_modules" and put "semver" there?!
					
					console.warn(`ERROR: LOCAL PACKAGE enforceVersion is NOT IMPLEMENTED, but WAS USED!!!!`);
					console.log(`LOCAL PACKAGE ${k} ${p.dependencies[k]} -> '${localPackage.path}'`);
					p.dependencies[k] = localPackage.path;
				} else {
					console.log(`LOCAL PACKAGE ${k} ${p.dependencies[k]} -> '${localPackage.path}'`);
					p.dependencies[k] = localPackage.path;					
				}
            }
        }
		if(context.ymultirepoRemap.packageIndex === 0)
			for (let k in p.devDependencies) {
			
				const localPackage = effectiveLocalPackages[k];
				if (localPackage) {
					if(localPackage.enforceVersion) {
						// TODO Check local package version against dependencies[k]
						// Use this package https://www.npmjs.com/package/semver
						// The only problem is that local_packages.js have no "node_modules" folder at all!
						// Should I use a subfolder (ymultirepo?) to host "node_modules" and put "semver" there?!
						
						console.warn(`ERROR: LOCAL PACKAGE enforceVersion is NOT IMPLEMENTED, but WAS USED!!!!`);
						console.log(`LOCAL PACKAGE ${k} ${p.devDependencies[k]} -> '${localPackage.path}'`);
						p.devDependencies[k] = localPackage.path;
					} else {
						console.log(`LOCAL PACKAGE ${k} ${p.devDependencies[k]} -> '${localPackage.path}'`);
						p.devDependencies[k] = localPackage.path;					
					}
				}
			}		
}

let localPackagesPaths;

function caseInsensitiveCompare(a, b) {
	if (typeof a === "string") a = a.toLowerCase();
	if (typeof b === "string") b = b.toLowerCase();
	return a < b ? -1 : a > b ? 1 : 0;
}

function checkedWriteFileSync(fileName, content, encoding = "utf-8") {
    if(typeof content !== "string" || content.trim().length < 3) {
        console.trace(`CODE00000000 FATAL ERROR - attempt to write empty or incorrect code to file '${fileName}', typeof content = "${typeof content}".\n\nFAIL FAST - TERMINATING PROCESS!`)
        process.exit(1);
    }

	let current;
	try {
		current = readFileSync(fileName, encoding);
	} catch (e) {
		if (e.code !== "ENOENT") throw e;
	}

	if (!current || current !== content) {
	    if(encoding === "TEST")
            console.warn(`checkedWriteFileSync ${fileName} - WILL WRITE ${content.length} chars!`);
        else
            writeFileSync(fileName, content, encoding);
		return true;
	}
	return false;
}

function ymultirepoClear() {
	localPackagesList.classification.default = [];
	localPackagesList.packages = {};
}

function ymultirepoScan() {
	const deletedPackageNames = new Set(Object.keys(localPackagesList.packages));

	for (let localPackagesPathItem of [LOCAL_PACKAGES_PATH_RESOLVED]) {
		let files;
		try {
			files = readdirSync(localPackagesPathItem, { withFileTypes: true });
		} catch (e) {
			if (e.message.startsWith("ENOENT")) {
				console.error(`CODE00000000 Path '${localPackagesPathItem}' - does not exists.`);
				continue;
			}
			throw e;
		}
		for (let filename of files) {
			if (filename.isDirectory()) {
				let packageJsonParsed;
				const folderPath = join(localPackagesPathItem, filename.name);
				try {
					const packageJsonPath = resolve(join(folderPath, "package.json"));
					packageJsonParsed = JSON.parse(readFileSync(packageJsonPath, "utf-8"));
				} catch (e) {
					if (e.code !== "ENOENT") throw e;
				}

				if (packageJsonParsed && packageJsonParsed.name && packageJsonParsed.name !== "undefined") {
					const { name, version } = packageJsonParsed;
					if (!localPackagesList.packages[name]) {
						localPackagesList.packages[name] = {};
					}
					const packageItem = localPackagesList.packages[name];
					deletedPackageNames.delete(packageItem.name);

					packageItem.name = name;
					packageItem.version = version;
					packageItem.path = folderPath;
				}
			}
		}

		for (let packageName of deletedPackageNames) delete localPackagesList.packages[packageName];
	}

	const fullPackageList = [
		...localPackagesList.classification.local,
		...localPackagesList.classification.nonLocal,
		...localPackagesList.classification.default,
	];
	for (let packageName in localPackagesList.packages)
		if (!fullPackageList.includes(packageName)) localPackagesList.classification.default.push(packageName);

	ymultirepoWriteList();
	return localPackagesList;
}


function ymultirepoWriteList() {
	localPackagesList.classification.local.sort(caseInsensitiveCompare);
	localPackagesList.classification.nonLocal.sort(caseInsensitiveCompare);
	localPackagesList.classification.default.sort(caseInsensitiveCompare);
	const contentOldStr = readFileSync(LOCAL_PACKAGES_LIST_PATH, 'utf-8');
	const contentOldArray = contentOldStr.split(splitter);
	if(contentOldArray.length!== 2) {
		console.error(`ERROR CODE00000000 Can't modify ${LOCAL_PACKAGES_LIST_PATH} contentOldArray.length = ${contentOldArray.length}, but 2 expected!`)
		process.exit(1);
	}
	const contentStr = `const localPackagesList = ${JSON.stringify(localPackagesList, undefined, "    ")};\n` + splitter + contentOldArray[1];
	if(contentOldArray[1].length < 500 || !contentStr.endsWith(contentOldArray[1])) {
		console.error(`ERROR CODE00000000 Can't modify ${LOCAL_PACKAGES_LIST_PATH} - internal error!`)
		process.exit(1);
	}

	checkedWriteFileSync(LOCAL_PACKAGES_LIST_PATH, contentStr, "utf-8");
	console.log(`CODE00000000 Written local packages list to '${LOCAL_PACKAGES_LIST_PATH}' successfully!`);
}

function ymultirepoPrintSnippet() {
	const snippet = `
// Put the following snippet into pnpmfile.js:
const {ymultirepoRemap, ymultirepoScan} = require("${LOCAL_PACKAGES_PATH}/local_packages_list");
module.exports = {
	hooks: {
		readPackage:ymultirepoRemap,
	},
};
`;
		console.log(snippet);
};


let policyCompareCalled = false;

const POLICY_CMP_ROOT = resolve(TEMP_DIR, "policy");
const POLICY_CMP_ETALON = resolve(POLICY_CMP_ROOT, "etalon");
const POLICY_CMP_ACTUAL = resolve(POLICY_CMP_ROOT, "actual");

function makePolicyCompareDirs() {
    if(!policyCompareCalled) {
        mkdirSync(POLICY_CMP_ROOT);
        mkdirSync(POLICY_CMP_ETALON);
        mkdirSync(POLICY_CMP_ACTUAL);
        policyCompareCalled = true;
    }
}

const POLICY_SPLITTER = "SYNC_APPEND";
class Policy {
    // this.policy = {
    // 	"files": {
    // 		"filename" : "notify" | "allow" | "delete" | "sync" | "syncJson",
    // 	}
    // }

    constructor(policyProjectPath) {
        this.policyProjectPath = policyProjectPath;
    }

    etalonPath(name) {
        return resolve(this.policyProjectPath, name);
    }

    readEtalon(name) {
        return readFileSync(this.etalonPath(name), "utf-8");
    }

    readEtalonJson(name) {
        return JSON.parse(this.readEtalon(name));
    }

    read() {
        this.policyPackage = this.readEtalonJson("package.json");
        this.name = policyPackage.name;

        try {
            this.policy = this.readEtalonJson("policy.json");
        } catch(e) {
            if (e.code !== "ENOENT") throw e;
        }

        if(undefined === this.policy) this.policy = {};
        if(undefined === this.policy.files) this.policy.files = {};
    }

    write() {
        checkedWriteFileSync(this.etalonPath("policy.json"), JSON.stringify(this.policy, undefined, "    "), "utf-8");
    }

    apply(targetProjectPath, updatingPolicyMode){
        if(undefined === this.policy)
            throw new Error(`CODE00000000 ERROR in Policy.apply: this.policy is undefined. Call .read() first!`);

        let packageJson
        try {
            packageJson = JSON.parse(readFileSync(resolve(targetProjectPath, "package.json"), "utf-8"));
        } catch (e) {
            console.error(`ERROR CODE00000000 Couldn't apply policy ${this.name} to project '${targetProjectPath}' because of error '${e.message}' when reading package.json `);
            return;
        }

        if(!packageJson || !packageJson.name || packageJson.name === "undefined") {
            console.error(`ERROR CODE00000000 Couldn't apply policy ${this.name} to project '${targetProjectPath}' because package.json have no valid 'name'`);
            return;
        }

        let files;
        try {
            files = readdirSync(targetProjectPath, { withFileTypes: true });
        } catch (e) {
            if (e.message.startsWith("ENOENT")) {
                console.error(`CODE00000000 ERROR in Policy.apply: path '${targetProjectPath}' - does not exists.`);
                return;
            }
            throw e;
        }

        for (let filename of files) {
            if (!filename.isDirectory()) {
                const filename = filename.name;
                const targetFullPath = resolve(targetProjectPath, filename.name);

                let filePolicy = this.policy.files[filename];
                if(undefined === filePolicy) {
                    filePolicy = this.policy.files[filename] = "notify";

                }

                switch(filePolicy) {
                    case "notify":
                        console.log(`POLICY NOTIFICATION: ${targetFullPath} - add this file to the policy or remove it.`);
                        break;
                    default:
                        console.warn(`POLICY WARNING: ${targetFullPath} - unknown policy mode '${filePolicy}'`);
                        break;
                    case "allowed":
                        break;
                    case "delete":
                        try {
                            unlinkSync(targetFullPath);
                            console.log(`POLICY DELETION: ${targetFullPath} - was deleted because of policy setting.`);
                        } catch(e) {
                            console.error(`POLICY DELETION: ${targetFullPath} - FAILED because of error: ${e.message}.`);
                        }
                        break;
                    case "sync":
                        this.syncFile(packageJson, filename, targetFullPath, overwrite, updatingPolicyMode);
                        break;
                    case "syncJson":
                        this.syncJsonFile(packageJson, filename, targetFullPath, overwrite, updatingPolicyMode);
                        break;
                }

            }
        }

        function syncFile(packageJson, filename, targetFullPath, overwrite, updatingPolicyMode) {
            const etalonStr = fileReadSync(this.etalonPath(filename), "utf-8");
            const etalonSplitted = etalonStr.split(POLICY_SPLITTER)[0];
            const haveSplitter = etalonStr !== etalonSplitted;
            const etalonRestored = (haveSplitter ? etalonSplitted + POLICY_SPLITTER : etalonStr)

            let contentStr;
            try {
                contentStr = fileReadSync(targetFullPath, "utf-8");
            } catch (e) {
                if (e.code !== "ENOENT") throw e;
            }

            let contentSplitted;
            if(contentStr) {
                let contentSplitted = contentStr.split(POLICY_SPLITTER)[0];
                if(contentSplitted === etalonSplitted)
                    return; // Equal - no actions needed
            }

            const newContent = (haveSplitter ? etalonRestored + (contentSplitted[1]||"") : etalonStr);
            if(!contentStr || overwrite) {
                checkedWriteFileSync(targetFullPath, newContent, "TEST", "utf-8");
            } else {
                makePolicyCompareDirs();

                const etalonCmpFileName = resolve(POLICY_CMP_ETALON, packageJson.name + "-" + filename);
                const actualCmpFileName = resolve(POLICY_CMP_ACTUAL, packageJson.name + "-" + filename);

                checkedWriteFileSync(etalonCmpFileName, newContent);
                linkSync(targetFullPath, actualCmpFileName);

                // HINT - DELETE LATER
                //		Про hardlink:
                //			- https://stackoverflow.com/questions/26695726/what-is-the-difference-between-fs-link-and-fs-symlink-are-they-platform-indepen
                //			- https://github.com/nodejs/node-v0.x-archive/issues/2274
                //			- https://tyapk.ru/blog/post/hardlink-and-symlink-windows
            }
        }

        function syncJsonFile(packageJson, filename, targetFullPath, overwrite, updatingPolicyMode) {
            const etalonObj = JSON.parse(fileReadSync(this.etalonPath(filename), "utf-8"));
            let shouldSaveEtalon = false;

            if(!etalonObj["!notify"]) { etalonObj["!notify"] = []; shouldSaveEtalon = true; }
            if(!etalonObj["!ignore"]) { etalonObj["!ignore"] = []; shouldSaveEtalon = true; }
            if(!etalonObj["!delete"]) { etalonObj["!delete"] = []; shouldSaveEtalon = true; }
            if(!etalonObj["!sync"]) { etalonObj["!sync"] = []; shouldSaveEtalon = true; }

            let contentStr;
            let contentObj;
            try {
                contentStr = fileReadSync(targetFullPath, "utf-8");
                contentObj = JSON.parse(contentStr);
            } catch (e) {
                if (e.code !== "ENOENT") throw e;
            }

            const newContentObj = { ...contentObj};

            const keys = {
                notify: new Set(etalonObj["!notify"]),
				ignore: new Set(etalonObj["!ignore"]),
				delete: new Set(etalonObj["!delete"]),
				sync: new Set(etalonObj["!sync"]),
			};

            for(let k in newContentObj) {
                if(keys.ignore.has(k)) {
                    // ignore them
                } else if(keys.delete.has(k)) {
                    delete contentObj[k];
                } else if(keys.sync.has(k)) {
                    contentObj[k] = etalonObj[k];
                } else {
                    if(keys.notify.has(k))
                        console.log(`POLICY NOTIFICATION: ${targetFullPath} . ${k} - add this key to the policy or remove it.`);
                    else {
                        keys.notify.add(k);
                        if(!etalonObj["!notify"]) etalonObj["!notify"] = [];
                        etalonObj["!notify"].push(k);
                        shouldSaveEtalon = true;
                    }
                }
            }

            if(shouldSaveEtalon)
                checkedWriteFileSync(this.etalonPath(filename), JSON.stringify(etalonObj,undefined, "    "), "TEST", "utf-8");

            const newContentStr = JSON.stringify(newContentObj, undefined, "    ");

            if(!contentStr || overwrite) {
                checkedWriteFileSync(targetFullPath, newContentStr, "TEST", "utf-8");
            } else {
                makePolicyCompareDirs();
                const etalonCmpFileName = resolve(POLICY_CMP_ETALON, packageJson.name + "-" + filename);
                const actualCmpFileName = resolve(POLICY_CMP_ACTUAL, packageJson.name + "-" + filename);

                checkedWriteFileSync(etalonCmpFileName, newContentStr);
                linkSync(targetFullPath, actualCmpFileName);
            }
        }
    }
}

function ymultirepoApplyPolicies() {
    for(let policyName in localPackagesList.policies) {
        const policyProjectNames = localPackagesList.policies[policyName];
        const policyPackage = localPackagesList.packages[policyName];
        if(!policyPackage || !policyPackage.path) {
            console.warn(`CODE00000000 ERROR Policy folder '${policyName}' - not found`);
        }

        const policy = new Policy(policyPackage.path);
        policy.read();
        for(let updatingPolicyMode=1; updatingPolicyMode>=0; updatingPolicyMode--) {
            for(let projectName of policyProjectNames) {
                const project = localPackagesList.packages[projectName];
                if(!project) continue;
                policy.apply(project.path, !!updatingPolicyMode);
            }
            policy.write();
        }
    }

    if(policyCompareCalled)
        execSync(`meld ${POLICY_CMP_ETALON} ${POLICY_CMP_ACTUAL}`, {stdio: 'inherit'});
}

module.exports = {ymultirepoScan, ymultirepoRemap};

if (require.main === module) {
	// This module called directly
	ymultirepoScan();
	// ymultirepoClear();
	// ymultirepoWriteList();
    // ymultirepoApplyPolicies(); // TODO JUST ENABLE AND TEST THIS
	ymultirepoPrintSnippet();
} else {
	// This module is required from some other module
	ymultirepoScan();
    // ymultirepoApplyPolicies(); // TODO JUST ENABLE AND TEST THIS
}

